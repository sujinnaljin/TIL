# 파티셔닝(Partitioning) vs. 샤딩(Sharding)

## 파티셔닝(Partitioning)

- 퍼포먼스(performance), 가용성(availability) 또는 정비용이성(maintainability)를 목적으로 논리적인 데이터 엘리먼트들을 다수의 엔티티(table)로 **쪼개는 행위**
- **수직 파티셔닝(vertical partitioning)** - 컬럼을 여러 테이블로 나누는 것
- **수평 파티셔닝(horizontal partitioning)** - 테이블의 Row 를 특정 컬럼 값을 기준으로 나누는 것. 이때  동일한 **하나의 인스턴스의 여러 테이블**에 나눠 저장.
  - 하나의 인스턴스내에서 여러 테이블로 나누는 것만으로도 인덱스의 크기가 작아지기 때문에, 인덱스 **조회 시간**이 **줄어**들으므로 **성능 향상**
  - 테이블이 크다면, 그만큼 인덱스의 크기도 커짐. 너무 큰 테이블로 인해 인덱스를 모두 메모리에 올려 처리할 수가 없게된다면, 이 또한 성능상 문제가 됨. 따라서 **테이블이 너무 큰 경우**에 파티셔닝을 한다면, **인덱스도 파편화**되기 때문에 **메모리를 효율적**으로 사용할 수 있음.

## 샤딩(Sharding)

- **수평 파티셔닝**과 동일하게 테이블의 Row 를 특정 컬럼 값을 기준으로한 여러 서브셋으로 나누어 저장 
- 하지만 **수평 파티셔닝**의 경우 **하나의 인스턴스의 여러 테이블**에 나눠 저장하는 반면, **샤딩**은 각 서브셋을 **여러 인스턴스**에 저장.
- 샤딩을 통해 **쿼리 (읽기, 쓰기)를 여러 인스턴스로 분산해서 처리**하도록 할 수 있음. 이를 통해 성능과 확장성 얻을 수 있음
- 샤딩을 하면 여러 샤드 노드들로 데이터가 분산되어 저장이 됨. 이때 **쿼리**에 **적절한 샤드키**가 **포함되지 않**는다면, **모든 노드**들로 쿼리를 **요청**(브로드캐스터 쿼리)하고 이를 다시 취합하여 응답. 반대로 **쿼리**에 **적절한 샤드키를 지정**한다면, 해당 데이터가 존재하는 인스턴스를 찾아 **타겟 쿼리**를 하게 됨.

- 샤드키를 잘못 선정하여, 데이터가 한쪽에 치우치게 된다거나, 한쪽에 쿼리가 몰리게 되는 현상이 발생하면 샤딩을 한 의미가 퇴색되므로, **적절한 샤드키**를 선정하여 **데이터가 고르고 쿼리를 적절히 분배**할 수 있도록 해야 함.
-  샤딩의 경우 성능상의 이슈 뿐아니라 **확장성**을 고려했을 때 당연히 고려해야함. 서비스의 사용자가 **수천만** 단위라면, **하나의 DB로 트래픽을 모두 받기는 어려**움 (Read 연산이 많은 서비스의 경우 Replication을 이용해서 어느정도 완화가 될 수 있겠지만, Write 연산 역시 많다면, 더더욱 그럴 것).  **Partitioning**의 경우 결국 **하나의 DB Instance**에서 이루어지는 것이기 때문에, 큰 규모의 시스템에서는 샤딩을 고려해보는 것이 좋음.



# 출처

- [Database - 샤딩과 파티셔닝](https://galid1.tistory.com/797)

